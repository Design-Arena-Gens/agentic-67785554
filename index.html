<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Drive</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#111;font-family:sans-serif}
canvas{display:block}
</style>
</head>
<body>
<script type="importmap">
{
"imports":{
"three":"https://unpkg.com/three@0.158.0/build/three.module.js",
"three/addons/":"https://unpkg.com/three@0.158.0/examples/jsm/"
}
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
const scene=new THREE.Scene();
scene.fog=new THREE.Fog(0x111111,60,180);
const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,500);
camera.position.set(0,10,18);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled=true;
document.body.appendChild(renderer.domElement);
const hemi=new THREE.HemisphereLight(0xffffff,0x222233,0.7);
scene.add(hemi);
const sun=new THREE.DirectionalLight(0xffffff,0.8);
sun.position.set(30,40,20);
sun.castShadow=true;
scene.add(sun);
const roadGroup=new THREE.Group();
const roadMat=new THREE.MeshStandardMaterial({color:0x333333});
const road=new THREE.Mesh(new THREE.PlaneGeometry(200,20),roadMat);
road.rotation.x=-Math.PI/2;
road.receiveShadow=true;
roadGroup.add(road);
const stripeMat=new THREE.MeshStandardMaterial({color:0xffffff});
for(let i=0;i<40;i++){
const stripe=new THREE.Mesh(new THREE.BoxGeometry(0.5,0.05,2),stripeMat);
stripe.position.set(0,0.01,i*5-100);
stripe.castShadow=false;
stripe.receiveShadow=true;
roadGroup.add(stripe);
}
const curbMat=new THREE.MeshStandardMaterial({color:0xffd37f});
const curbGeo=new THREE.BoxGeometry(0.5,0.3,200);
const leftCurb=new THREE.Mesh(curbGeo,curbMat);
leftCurb.position.set(-10,0.15,0);
leftCurb.receiveShadow=true;
roadGroup.add(leftCurb);
const rightCurb=leftCurb.clone();
rightCurb.position.x=10;
roadGroup.add(rightCurb);
scene.add(roadGroup);
const car=new THREE.Group();
const bodyMat=new THREE.MeshStandardMaterial({color:0x1e90ff,metalness:0.3,roughness:0.4});
const body=new THREE.Mesh(new THREE.BoxGeometry(1.8,0.8,3.2),bodyMat);
body.position.y=0.9;
body.castShadow=true;
car.add(body);
const cabin=new THREE.Mesh(new THREE.BoxGeometry(1.3,0.7,1.6),new THREE.MeshStandardMaterial({color:0xeeeeff,transparent:true,opacity:0.9}));
cabin.position.set(0,1.2,-0.1);
car.add(cabin);
const wheelGeo=new THREE.CylinderGeometry(0.45,0.45,0.35,20);
wheelGeo.rotateZ(Math.PI/2);
const wheelMat=new THREE.MeshStandardMaterial({color:0x111111,roughness:0.9,metalness:0.1});
const wheelPos=[[-0.9,0.45,1.2],[0.9,0.45,1.2],[-0.9,0.45,-1.4],[0.9,0.45,-1.4]];
wheelPos.forEach(p=>{
const wheel=new THREE.Mesh(wheelGeo,wheelMat);
wheel.position.set(p[0],p[1],p[2]);
wheel.castShadow=true;
car.add(wheel);
});
car.position.z=-20;
scene.add(car);
const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;
controls.enablePan=false;
controls.minDistance=6;
controls.maxDistance=25;
controls.maxPolarAngle=Math.PI/2.15;
controls.update();
const keys={};
window.addEventListener('keydown',e=>{keys[e.code]=true;});
window.addEventListener('keyup',e=>{keys[e.code]=false;});
let speed=0;
let steer=0;
const maxSpeed=0.5;
const accel=0.012;
const brake=0.02;
const friction=0.008;
const steerStrength=0.04;
const bounds=8.5;
const clock=new THREE.Clock();
function updateCar(dt){
if(keys.ArrowUp||keys.KeyW)speed=Math.min(maxSpeed,speed+accel);
if(keys.ArrowDown||keys.KeyS)speed=Math.max(-maxSpeed*0.6,speed-accel);
if(!keys.ArrowUp&&!keys.ArrowDown&&!keys.KeyW&&!keys.KeyS){
if(speed>0)speed=Math.max(0,speed-friction);
else if(speed<0)speed=Math.min(0,speed+friction);
}
if(keys.Space){
if(speed>0)speed=Math.max(0,speed-brake);
if(speed<0)speed=Math.min(0,speed+brake);
}
const steerInput=(keys.ArrowLeft||keys.KeyA?1:0)-(keys.ArrowRight||keys.KeyD?1:0);
if(steerInput!==0){
steer=THREE.MathUtils.lerp(steer,steerInput*steerStrength,0.1);
}else{
steer=THREE.MathUtils.lerp(steer,0,0.15);
}
car.rotation.y-=steer*speed*5;
const forward=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
car.position.addScaledVector(forward,speed*10*dt);
car.position.x=THREE.MathUtils.clamp(car.position.x,-bounds,bounds);
car.position.y=0;
if(Math.abs(car.position.x)>=bounds)car.rotation.y+=steer*0.2;
}
function updateCamera(dt){
const targetOffset=new THREE.Vector3(0,3,7).applyQuaternion(car.quaternion);
const desiredPos=car.position.clone().add(targetOffset);
camera.position.lerp(desiredPos,1-Math.pow(0.001,dt));
const target=car.position.clone().add(new THREE.Vector3(0,1,0));
controls.target.copy(target);
controls.update();
}
function animate(){
const dt=clock.getDelta();
updateCar(dt);
updateCamera(dt);
renderer.render(scene,camera);
requestAnimationFrame(animate);
}
animate();
window.addEventListener('resize',()=>{
camera.aspect=window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
